/*****************************************************************************
* Model: emitter_receiver_gateway.qm
* File:  ./src/radio433.cpp
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::src::radio433.cpp} ..................................................*/
#include "Radio433.h"


#if ((QP_VERSION < 591) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpn version 5.9.1 or higher required
#endif

/*${AOs::Radio433} .........................................................*/
/*${AOs::Radio433::SM} .....................................................*/
QState Radio433_initial(Radio433 * const me) {
    /* ${AOs::Radio433::SM::initial} */
    return Q_TRAN(&Radio433_INITIAL);
}
/*${AOs::Radio433::SM::IDLE} ...............................................*/
QState Radio433_IDLE(Radio433 * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Radio433::SM::IDLE} */
        case Q_ENTRY_SIG: {
            Serial.println("433Mhz module idleing");
            // TODO cut receiver power
            // reset timer config?
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Radio433::SM::IDLE::MODE_RECEIVER} */
        case MODE_RECEIVER_SIG: {
            status_ = Q_TRAN(&Radio433_RECEIVING);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Radio433::SM::RECEIVING} ..........................................*/
QState Radio433_RECEIVING(Radio433 * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Radio433::SM::RECEIVING} */
        case Q_ENTRY_SIG: {
            Serial.print(F("433Mhz module enter receiver mode ("));
            Serial.print(BAUDRATES[me->m_SpeedFactor]);
            Serial.println(F(")bps"));

            // TODO activate power on receiver


            man.setup(RADIO433_TX_PIN, RADIO433_RX_PIN, me->m_SpeedFactor);


            man.beginReceiveArray(RADIO433_BUFFER_SIZE, me->RADIO433_BUFFER_);

            QActive_armX(&me->super, 0U, BSP_TICKS_PER_SEC/5, 0U);

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Radio433::SM::RECEIVING} */
        case Q_EXIT_SIG: {
            man.stopReceive();

            for(uint8_t i = 0 ; i < RADIO433_BUFFER_SIZE; ++i)
            {
                me->RADIO433_BUFFER_[i] = 0;
            }
            Serial.println(F("Reception stopped and buffer cleared"));

            QActive_disarmX(&me->super, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Radio433::SM::RECEIVING::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            if (man.receiveComplete())
            {
                Serial.println();
                Serial.println("-----------"); // device
                //do something with the data in 'buffer' here before you start receiving to the same buffer again
                Serial.print("Device id:"); // device
                Serial.println(me->RADIO433_BUFFER_[1]); // device


                Serial.print("Sensor type:"); // device
                Serial.println(me->RADIO433_BUFFER_[2]); // sensor type

                Serial.print(me->RADIO433_BUFFER_[3]); // byte 1
                Serial.print(".");
                Serial.print(me->RADIO433_BUFFER_[4]); // byte 2
                Serial.println("Â°C");

                man.beginReceiveArray(RADIO433_BUFFER_SIZE, me->RADIO433_BUFFER_);
            }
            QActive_armX(&me->super, 0U, BSP_TICKS_PER_SEC, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Radio433::SM::RECEIVING::MODE_IDLE} */
        case MODE_IDLE_SIG: {
            status_ = Q_TRAN(&Radio433_IDLE);
            break;
        }
        /* ${AOs::Radio433::SM::RECEIVING::NEW_SPEED_FACTOR} */
        case NEW_SPEED_FACTOR_SIG: {
            uint8_t newSpeed = (uint8_t)(Q_PAR(me));

            newSpeed -= 48; // 48 is char code for 0

            if(newSpeed < 8)
            {
                Serial.print(F("Reconfigure baud rate for "));
                Serial.print(BAUDRATES[me->m_SpeedFactor]);
                Serial.println(F(" bps"));
                me->m_SpeedFactor = newSpeed;
            }
            else
            {
                Serial.println(F("Invalid baudrate value received"));
            }
            status_ = Q_TRAN(&Radio433_RECEIVING);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Radio433::SM::INITIAL} ............................................*/
QState Radio433_INITIAL(Radio433 * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Radio433::SM::INITIAL} */
        case Q_ENTRY_SIG: {
            Serial.println("433Mhz module configured");

            // default value for speed factor from constant
            me->m_SpeedFactor = RADIO433_FACTOR;

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Radio433::SM::INITIAL::MODE_IDLE} */
        case MODE_IDLE_SIG: {
            status_ = Q_TRAN(&Radio433_IDLE);
            break;
        }
        /* ${AOs::Radio433::SM::INITIAL::MODE_RECEIVER} */
        case MODE_RECEIVER_SIG: {
            status_ = Q_TRAN(&Radio433_RECEIVING);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

